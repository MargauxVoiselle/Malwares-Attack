#include "stdafx.h"
#include <windows.h> 
#include <stdio.h>
#include <wincrypt.h>

// Peut être à remplacer directement dans le code dans la version finale
#define ENCRYPT_ALGORITHM CALG_AES_128
#define BUFSIZE 1024

HCRYPTPROV hCryptProv;
// Cacher avec un VirtualProtect dans la version finale
HCRYPTKEY * hKeyPtr = (HCRYPTKEY *) malloc(sizeof(HCRYPTKEY));

void encrypt(char * input, DWORD * length);
void decrypt(char * encryptedInput, DWORD * length);
BYTE * calculateHash(char* input, DWORD* hashSize);
bool compareHash(char * hashUserInput);

char * input = (char *) malloc(512);
char * winnerInput = (char *) malloc(512);

int _tmain(int argc, _TCHAR* argv[])
{
	printf("Veuillez rentrer un input de 32 caractères hexadécimaux ou moins :\n");
	// %32 à changer pour faire notre propre action si les règles d'input ne sont pas respectées
    // if (condition non respectée) faire ?
	scanf("%32s", input);
	printf("Vous avez choisi l'input suivant : %s\n", input);

	DWORD inputLength = strlen(input);
    // Besoin de la taille initiale pour l'affichage final de la chaîne
	DWORD initialLength = strlen(input);

	if (!CryptAcquireContext(
        &hCryptProv,
        NULL,
        NULL,
        PROV_RSA_AES,
        0))
    {
        printf("Error during CryptAcquireContext!\n");
        exit(1);
    }

	if(!CryptGenKey(
		hCryptProv, 
        ENCRYPT_ALGORITHM, 
        CRYPT_EXPORTABLE,
        hKeyPtr))
	{
		printf("Error during CryptGenKey.\n"); 
        exit(1);
	}
	
    // Chiffrement de la chaîne rentrée par l'utilisateur
	encrypt(input, &inputLength);
	printf("Input chiffré: %s\n", input);

	// **************************************************
    // Besoin de créer une copie locale puisque la fonction
    // de hash ne semble pas modifier l'input ?
    // **************************************************

	char * inputToHash = (char *) malloc(512);
	strcpy(inputToHash, input);
	DWORD hashSize;

	printf("Valeur de la variable à hasher : %s\n", inputToHash);
	BYTE * calculatedHash = calculateHash(inputToHash, &hashSize);

    if (calculatedHash == NULL)
    {
        printf("Error calculating hash\n");
        exit(1);
    }

	printf("Hash Value: ");
    for (DWORD i = 0; i < hashSize; i++)
    {
        printf("%02x", calculatedHash[i]);
    }
    printf("\n");
		
	// Comparaison du hash de l'input et du hash gagnant
	compareHash(inputToHash);

    // Déchiffrement de la chaîne rentrée par l'utilisateur chiffrée
    decrypt(input, &inputLength);
    // Affichage réduit sur la taille initiale de l'input
	printf("Input en clair : %.*s\n", initialLength, input);

	while(1);
	return 0;
}

void encrypt(char * input, DWORD * length)
{
    printf("\nDébut du chiffrement de la chaîne %s\n", input);
    printf("Longueur : %d\n", *length);

    // Il faudra rendre la clé accessible en écriture si jamais elle est cachée par un VirtualProtect 
	//DWORD oldPermissions;
	//VirtualProtect(hKeyPtr, 100, PAGE_EXECUTE_READWRITE, &oldPermissions);

	if (!CryptEncrypt(*hKeyPtr,
		NULL, 
        1,  
        0, 
        (BYTE *) input, 
        length,
        1024))
    {   
		printf("Encryption failed\n");
		exit(1);
	}

    printf("Fin du chiffrement de la chaîne\n\n");
}

void decrypt(char * encryptedInput, DWORD * length)
{
    printf("\nDébut du déchiffrement de la chaîne %s\n", encryptedInput);
    printf("Longueur : %d\n", *length);

    if (!CryptDecrypt(*hKeyPtr,
        NULL,
        1,
        0,
        (BYTE *) encryptedInput,
        length))
    {
        printf("Decryption failed\n");
        exit(1);
    }
    
    printf("Fin du déchiffrement de la chaîne\n\n");
}

BYTE * calculateHash(char* input, DWORD* hashSize)
{
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbHash[BUFSIZE];
    DWORD cbHash = 0;
    DWORD dwCount;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
    {
        printf("Error during CryptAcquireContext!\n");
        return NULL;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
    {
        printf("Error during CryptCreateHash!\n");
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    if (!CryptHashData(hHash, (BYTE*) input, strlen(input), 0))
    {
        printf("Error during CryptHashData!\n");
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        return NULL;
    }

    cbHash = sizeof(rgbHash);
    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
        printf("Error during CryptGetHashParam!\n");
    }

    BYTE* hashResult = (BYTE*) malloc(BUFSIZE);

    if (hashResult == NULL)
    {
        printf("Memory allocation error!\n");
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    memcpy(hashResult, rgbHash, cbHash);
    *hashSize = cbHash;

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    return hashResult;
}


bool compareHash(char * inputToHash)
{
	char* sourceString = "df0a8b5c13e72f6d9c8f14e7a2b6390a";
    strcpy(winnerInput, sourceString);
    printf("L'entrée gagnante est : %s\n", winnerInput);

	DWORD winnerInputLength = strlen(winnerInput);
	encrypt(winnerInput, &winnerInputLength);

    // Calcul du hash du chiffré puis comparaison des hash à faire
    // Il faut peut être modifier l'argument de la fonction et mettre le tableau de byte représentant le hash plutôt
	return true;
}
