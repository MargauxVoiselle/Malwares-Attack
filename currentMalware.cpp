#include "stdafx.h"
#include <windows.h> 
#include <stdio.h>
#include <wincrypt.h>
#define ENCRYPT_ALGORITHM CALG_AES_128
#define BUFSIZE 1024

HCRYPTPROV hCryptProv;
// à cacher
HCRYPTKEY * hKeyPtr = (HCRYPTKEY *) malloc(sizeof(HCRYPTKEY));
	
void encrypt(char * input, DWORD * length);
void decrypt(char * encryptedInput, DWORD * length);
BYTE * calculateHash(char* input, DWORD* hashSize);
bool compareHash(char * hashUserInput);

char * input = (char *) malloc(33*sizeof(char));

char * winInput = (char *) malloc(33*sizeof(char));

int _tmain(int argc, _TCHAR* argv[])
{
	printf("Input?\n");
	// %32 à changer
	scanf("%32s", input);
	printf("Votre input est %s\n", input);

	DWORD length = strlen(input);
	DWORD initialLength = strlen(input);

	printf("\nDébut du chiffrement\n");
	if (CryptAcquireContext(
        &hCryptProv,
        NULL,
        NULL,
        PROV_RSA_AES,
        0))
    {
        printf("A cryptographic provider has been acquired. \n");
    }
    else
    {
        printf("Error during CryptAcquireContext!\n");
        exit(1);
    }

	if(CryptGenKey(
		hCryptProv, 
        ENCRYPT_ALGORITHM, 
        CRYPT_EXPORTABLE,
        hKeyPtr))
	{
		printf("A session key has been created.\n");
	} 
	else
	{
		printf("Error during CryptGenKey.\n"); 
        exit(1);
	}
	
	// Encrypt the input
	encrypt(input, &length);

	printf("Encrypted Text: %s\n", input);
	printf("Fin du chiffrement\n");

	/////////////////////////////////////////

	char * inputToHash = (char *) malloc(length * sizeof(char));
	strcpy(inputToHash, input);
	DWORD hashSize;

	printf("\nDébut du hashage\n");
	printf("Variable locale pour le hash : %s\n", inputToHash);
	BYTE * calculatedHash = calculateHash(inputToHash, &hashSize);
	printf("Fin du hashage\n");

	if (calculatedHash != NULL) {
        printf("Hash Value: ");
        for (DWORD i = 0; i < hashSize; i++) {
            printf("%02x", calculatedHash[i]);
        }
        printf("\n");
		printf("heuuu\n");
    } else {
        printf("Error calculating hash\n");
    }

	printf("Comparaison\n");
	compareHash(inputToHash);


	//////////////////////////////////////////

	printf("\nDébut du déchiffrement\n");
    // Decrypt the encrypted input
    decrypt(input, &length);

	printf("Decrypted Text: %.*s\n", initialLength, input);
	printf("Fin du déchiffrement\n");

	while(1);
	return 0;
}

void encrypt(char * input, DWORD * length){
	//DWORD oldPermissions;
	//VirtualProtect(hKeyPtr, 100, PAGE_EXECUTE_READWRITE, &oldPermissions);

	printf("PlainText: %s\n",input);
    printf("Buf Len: %d\n",*length);

	if (!CryptEncrypt(*hKeyPtr,
		NULL, 
        1,  
        0, 
        (BYTE *) input, 
        length,
        32)) {   
		printf("Encryption failed\n");
		exit(1);
	}
}

void decrypt(char * encryptedInput, DWORD * length)
{
    if (!CryptDecrypt(*hKeyPtr,
        NULL,
        1,
        0,
        (BYTE *) encryptedInput,
        length))
    {
        printf("Decryption failed\n");
        exit(1);
    }
}

BYTE * calculateHash(char* input, DWORD* hashSize) {
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbHash[BUFSIZE];
    DWORD cbHash = 0;
    DWORD dwCount;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        printf("Error during CryptAcquireContext!\n");
        return NULL;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        printf("Error during CryptCreateHash!\n");
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    if (!CryptHashData(hHash, (BYTE*)input, strlen(input), 0)) {
        printf("Error during CryptHashData!\n");
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        return NULL;
    }

    cbHash = sizeof(rgbHash);
    if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
        printf("Hash Value: ");
        for (dwCount = 0; dwCount < cbHash; dwCount++)
            printf("%02x", rgbHash[dwCount]);
        printf("\n");
    }
    else {
        printf("Error during CryptGetHashParam!\n");
    }

    BYTE* hashResult = (BYTE*)malloc(BUFSIZE);

    if (hashResult == NULL) {
        printf("Memory allocation error!\n");
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return NULL;
    }

    // Copier le hash dans le tableau alloué
    memcpy(hashResult, rgbHash, cbHash);

    // Indiquer la taille du hash
    *hashSize = cbHash;

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    // Retourner le tableau de BYTE contenant le hash
    return hashResult;
}


bool compareHash(char * inputToHash){
	// PROBLEME ICI QUAND df0a8b5c13e72f6d9c8f14e7a2b6390a (mais fonctionne pour df0a8b5c13e72f6d9c8f14e7a2b6390 ou des chaînes plus courtes)
	char* sourceString = "df0a8b5c13e72f6d9c8f14e7a2b6390";
    strcpy(winInput, sourceString);

    // Afficher le résultat
    printf("winInput: %s\n", winInput);

	DWORD winInputLength = strlen(winInput);

	encrypt(winInput, &winInputLength);

	printf("Encrypted Text: %s\n", winInput);
	printf("Fin du chiffrement\n");

	return true;
}
