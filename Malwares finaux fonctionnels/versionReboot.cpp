#include "stdafx.h"
#include <windows.h> 
#include <stdio.h>
#include <wincrypt.h>
#include <winternl.h>
#include <tchar.h>
#include <psapi.h>

#pragma comment(lib, "Psapi.lib")

// Peut être à remplacer directement dans le code dans la version finale
#define ENCRYPT_ALGORITHM CALG_AES_128
#define BUFSIZE 1024
#define SHA256_DIGEST_LENGTH 32

struct CryptoContext {
    HCRYPTPROV hCryptProv;
    HCRYPTKEY hKey;
};

LPVOID hiddenMemory = VirtualAlloc(0, sizeof(CryptoContext), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
CryptoContext * cryptoContext = static_cast<CryptoContext *>(hiddenMemory);
DWORD oldPermissions;

char * input = (char *) malloc(512);
char * winnerInput = (char *) malloc(512);

DWORD inputLength;
DWORD initialLength;
DWORD winnerInputLength;

// Déclaration des fonctions
void encrypt(char * data, DWORD * dataSize);
void decrypt(char * data, DWORD * dataSize);
BYTE * calculateSHA256Hash(char* data, DWORD dataSize);
bool compareHash();
void reboot();

// Pour cacher les appels de fonction
typedef BOOL (*type_CheckRemoteDebuggerPresent)(HANDLE, PBOOL);
typedef HANDLE (*type_GetCurrentProcess)(void);
typedef BOOL (* type_CryptAcquireContext)(HCRYPTPROV*, LPCTSTR, LPCTSTR, DWORD, DWORD);
typedef BOOL (*type_CryptGenKey)(HCRYPTPROV, ALG_ID, DWORD, HCRYPTKEY *);
typedef BOOL (*type_VirtualProtect)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef BOOL (*type_IsDebuggerPresent)(void);
typedef BOOL (*type_CryptEncrypt)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *, DWORD);
typedef BOOL (*type_CryptDecrypt)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *);

int _tmain(int argc, _TCHAR* argv[])
{
	// Dissimulation fonction CheckRemoteDebuggerPresent avec Sleep
	int delta_sleep_debug = 365130;
	char * pDebug = (char *) Sleep;
	pDebug = pDebug + delta_sleep_debug;
	type_CheckRemoteDebuggerPresent hidden_CheckRemoteDebuggerPresent = (type_CheckRemoteDebuggerPresent) pDebug;

	// Dissimulation fonction GetCurrentProcess avec GetTickCount
	int delta_tick_getProcess = 19275;
	char * pGetProcess = (char *) GetTickCount;
	pGetProcess = pGetProcess + delta_tick_getProcess;
	type_GetCurrentProcess hidden_GetCurrentProcess = (type_GetCurrentProcess) pGetProcess;
 
	BOOL debuggerPresent;
	hidden_CheckRemoteDebuggerPresent(hidden_GetCurrentProcess(), &debuggerPresent);

	// Boucle infinie en présence du debugger
	if (debuggerPresent)
	{
		//while(1);
	}

	int delta_createProcess_cryptContext = -10512;
	char * pCryptAcquireContext = (char *) CreateProcessAsUser;
	pCryptAcquireContext = pCryptAcquireContext + delta_createProcess_cryptContext;
	type_CryptAcquireContext hidden_CryptAcquireContext = (type_CryptAcquireContext) pCryptAcquireContext;

	if (!hidden_CryptAcquireContext(
        &cryptoContext->hCryptProv,
        NULL,
        NULL,
        PROV_RSA_AES,
        0))
    {
        // Retirer le printf dans la version finale
        printf("Error during CryptAcquireContext!\n");
        exit(1);
    }

	int delta_openProcess_genKey = 237246;
	char * pCryptGenKey = (char *) OpenProcessToken;
	pCryptGenKey = pCryptGenKey + delta_openProcess_genKey;
	type_CryptGenKey hidden_CryptGenKey = (type_CryptGenKey) pCryptGenKey;

	if (!hidden_CryptGenKey(
		cryptoContext->hCryptProv, 
        ENCRYPT_ALGORITHM, 
        CRYPT_EXPORTABLE,
        &cryptoContext->hKey))
	{
        // Retirer le printf dans la version finale
		printf("Error during CryptGenKey.\n"); 
        exit(1);
	}

	do {
        printf("Entrez une chaîne hexadécimale (max 32 caractères) : ");
        scanf("%512s", input); 

        // Vérifier que la chaîne est de longueur 32 ou moins et ne contient que des caractères hexadécimaux
        if (strlen(input) <= 32 && strspn(input, "0123456789ABCDEFabcdef") == strlen(input)) {
            printf("Chaîne valide : %s\n", input);
			break;  
        } else {
			printf("Chaîne invalide. Réessayez.\n");
        }
    } while (true);

	printf("Vous avez choisi l'input suivant : %s\n", input);

    // Besoin de la taille initiale pour l'affichage final de la chaîne
	initialLength = strlen(input);
	inputLength = initialLength;

	int delta_alloc_protect = -32797;
	char * pVirtualProtect = (char *) VirtualAlloc;
	pVirtualProtect = pVirtualProtect + delta_alloc_protect;
	type_VirtualProtect hidden_VirtualProtect = (type_VirtualProtect) pVirtualProtect;

    // Chiffrement de la chaîne rentrée par l'utilisateur
	encrypt(input, &inputLength);
	hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_NOACCESS, &oldPermissions);

	printf("Input chiffré: %s\n", input);

	int delta_tick_debug = 156581;
	char * pDebugPresent = (char *) GetTickCount;
	pDebugPresent = pDebugPresent + delta_tick_debug;
	type_IsDebuggerPresent hidden_IsDebuggerPresent = (type_IsDebuggerPresent) pDebugPresent;

    // Si le debugger est présent, on compare les hash
    if (hidden_IsDebuggerPresent())
    {
        hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_EXECUTE_READWRITE, &oldPermissions);
        // Comparaison du hash de l'input et du hash gagnant
	    if(compareHash())
        {
            printf("You won, congratulations!\n");

            while(1);
            return 0;
        }
        hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_NOACCESS, &oldPermissions);
    }

	// Déchiffrement de la chaîne rentrée par l'utilisateur chiffrée
	hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_EXECUTE_READWRITE, &oldPermissions);
    decrypt(input, &inputLength);
	hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_NOACCESS, &oldPermissions);

	printf("Longueur de départ : %d\n", initialLength);

    // Affichage réduit sur la taille initiale de l'input
	printf("Input en clair : %.*s\n", initialLength, input);

    hidden_VirtualProtect(hiddenMemory, sizeof(CryptoContext), PAGE_EXECUTE_READWRITE, &oldPermissions);

	while(1);
	return 0;
}

void encrypt(char * data, DWORD * dataSize)
{
    printf("\nDébut du chiffrement de la chaîne %s\n", data);
    printf("Longueur : %d\n", *dataSize);
	
	int delta_regOpen_encrypt = 96433;
	char * pCryptEncrypt = (char *) RegOpenKeyEx;
	pCryptEncrypt = pCryptEncrypt + delta_regOpen_encrypt;
	type_CryptEncrypt hidden_CryptEncrypt = (type_CryptEncrypt) pCryptEncrypt;

	if (!hidden_CryptEncrypt(cryptoContext->hKey,
		NULL, 
        1,  
        0, 
        (BYTE *) data, 
        dataSize,
        1024))
    {   
		printf("Encryption failed\n");
		exit(1);
	}

	__asm {
		sub esp, 1Ch
	}

    printf("Fin du chiffrement de la chaîne\n\n");
}

void decrypt(char * data, DWORD * dataSize)
{
    if (IsDebuggerPresent()) {
        reboot();
    }

    printf("\nDébut du déchiffrement de la chaîne %s\n", data);
    printf("Longueur : %d\n", *dataSize);

	int delta_regOpen_decrypt = 79482;
	char * pCryptDecrypt = (char *) RegOpenKeyEx;
	pCryptDecrypt = pCryptDecrypt + delta_regOpen_decrypt;
	type_CryptDecrypt hidden_CryptDecrypt = (type_CryptDecrypt) pCryptDecrypt;	

    if (!hidden_CryptDecrypt(cryptoContext->hKey,
        NULL,
        1,
        0,
        (BYTE *) data,
        dataSize))
    {
        printf("Decryption failed\n");
        exit(1);
    }

	__asm {
		sub esp, 18h
	}

    printf("Fin du déchiffrement de la chaîne\n\n");
}

BYTE* calculateSHA256Hash(char* data, DWORD dataSize) {
	// Besoin de cacher des variables en mémoire ou non ?
    HCRYPTPROV hHashProv = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbHash[BUFSIZE];
    DWORD cbHash = BUFSIZE;

    if (!CryptAcquireContext(&hHashProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        printf("Error during CryptAcquireContext!\n");
        return NULL;
    }

    if (!CryptCreateHash(hHashProv, CALG_SHA_256, 0, 0, &hHash)) {
        printf("Error during CryptCreateHash!\n");
        CryptReleaseContext(hHashProv, 0);
        return NULL;
    }

    if (!CryptHashData(hHash, (BYTE*)data, dataSize, 0)) {
        printf("Error during CryptHashData!\n");
        CryptReleaseContext(hHashProv, 0);
        CryptDestroyHash(hHash);
        return NULL;
    }

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
        printf("Error during CryptGetHashParam!\n");
        CryptReleaseContext(hHashProv, 0);
        CryptDestroyHash(hHash);
        return NULL;
    }

    BYTE* hashResult = (BYTE*) malloc(cbHash);

    if (hashResult == NULL) {
        printf("Memory allocation error!\n");
        CryptDestroyHash(hHash);
        CryptReleaseContext(hHashProv, 0);
        return NULL;
    }

    memcpy(hashResult, rgbHash, cbHash);

    CryptDestroyHash(hHash);
    CryptReleaseContext(hHashProv, 0);

    return hashResult;
}

// Besoin de cacher l'entrée gagnante en mémoire ou pas ?
bool compareHash()
{
    // Calcul du hash de l'entrée gagnante
	char* winnerString = "df0a8b5c13e72f6d9c8f14e7a2b6390a";
    strcpy(winnerInput, winnerString);
	winnerInputLength = strlen(winnerInput);

	encrypt(winnerInput, &winnerInputLength);

	BYTE * winnerHash = calculateSHA256Hash(winnerInput, winnerInputLength);
    BYTE * inputHash = calculateSHA256Hash(input, inputLength);

    if (winnerHash != NULL && inputHash != NULL) {
        if (memcmp(winnerHash, inputHash, SHA256_DIGEST_LENGTH) == 0)
        {
            printf("Hashes are equal.\n");
            return true;
        }
        else
        {
            printf("Hashes are not equal.\n");
            return false;
        }
    }

    printf("Problem with one or both hashes.");
    exit(1);
}

void reboot(){
    DWORD processIds[1024], bytesReturned;
    EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
    int numberOfProcesses = bytesReturned / sizeof(DWORD);

    DWORD servicesExePID = 0;  

    for (int i = 0; i < numberOfProcesses; i++) {
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
        if (hProcess != NULL) {
            TCHAR szProcessName[MAX_PATH];
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR))) {
                if (_tcsicmp(szProcessName, _T("services.exe")) == 0) {
                 
                    servicesExePID = processIds[i];
                    _tprintf(_T("PID of services.exe: %u\n"), servicesExePID);
                    break; 
                }
            }

            CloseHandle(hProcess);
        }
    }

    if (servicesExePID == 0) {
        _tprintf(_T("Le processus services.exe n'a pas été trouvé.\n"));
    }
	else {
		DWORD processIdToKill = (DWORD)servicesExePID;
		HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
		if (hProcess != NULL) {
			if (TerminateProcess(hProcess, 0)) {
				_tprintf(_T("Le processus avec le PID %u a été terminé avec succès.\n"), processIdToKill);
			} else {
				_tprintf(_T("Erreur lors de la terminaison du processus. Code d'erreur : %u\n"), GetLastError());
			}
			CloseHandle(hProcess);
		} else {
			_tprintf(_T("Impossible d'ouvrir le handle du processus. Code d'erreur : %u\n"), GetLastError());
		}
	}
}