#include "stdafx.h"
#include <windows.h> 
#include <stdio.h>
#include <wincrypt.h>
#include <winternl.h>
#include <tchar.h>
#include <psapi.h>
#include <tlhelp32.h>

#pragma comment(lib, "Psapi.lib")

#define ENCRYPT_ALGORITHM CALG_AES_128
#define BUFSIZE 1024
#define SHA256_DIGEST_LENGTH 32

struct CryptoContext {
    HCRYPTPROV hCryptProv;
    HCRYPTKEY hKey;
	int xorKey;
};

LPVOID hiddenMemory = VirtualAlloc(0, sizeof(CryptoContext), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
CryptoContext * cryptoContext = static_cast<CryptoContext *>(hiddenMemory);
DWORD oldPermissions;

char * input = (char *) malloc(512);
char * winnerInput = (char *) malloc(512);
TCHAR szProcessName[MAX_PATH];

DWORD inputLength;
DWORD initialLength;
DWORD winnerInputLength;

void encrypt(char * data, DWORD * dataSize);
void decrypt(char * data, DWORD * dataSize);
BYTE * calculateSHA256Hash(char* data, DWORD dataSize);
bool compareHash();
void reboot();
void findNeedToReboot(int * xorKeys);

typedef BOOL (*type_CheckRemoteDebuggerPresent)(HANDLE, PBOOL);
typedef HANDLE (*type_GetCurrentProcess)(void);
typedef BOOL (* type_CryptAcquireContext)(HCRYPTPROV*, LPCTSTR, LPCTSTR, DWORD, DWORD);
typedef BOOL (*type_CryptGenKey)(HCRYPTPROV, ALG_ID, DWORD, HCRYPTKEY *);
typedef BOOL (*type_VirtualProtect)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef BOOL (*type_IsDebuggerPresent)(void);
typedef BOOL (*type_CryptEncrypt)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *, DWORD);
typedef BOOL (*type_CryptDecrypt)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *);
typedef BOOL (*type_CryptCreateHash)(HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH *);
typedef BOOL (*type_CryptGetHashParam)(HCRYPTHASH, DWORD, BYTE *, DWORD *, DWORD);
typedef BOOL (*type_EnumProcesses) (DWORD*, DWORD, LPDWORD);
typedef HANDLE (*type_OpenProcess) (DWORD, BOOL, DWORD);
typedef BOOL (*type_TerminateProcess) (HANDLE, UINT);
typedef BOOL (*type_Process32First) (HANDLE, LPPROCESSENTRY32);
typedef BOOL (*type_Process32Next) (HANDLE, LPPROCESSENTRY32);

unsigned char tabIsDebuggerPresentXor[] = {0x21, 0xe4, 0x5d, 0x45, 0x45, 0x45, 0xce, 0x05, 0x75, 0x4a, 0xf3, 0x05, 0x47, 0x86};

void dechiffre(char * position){
	for(int i = 0 ; i < 14 ; i ++)
	{
		position[i] = tabIsDebuggerPresentXor[i] ^ 0x45; 
	}
}

TCHAR* xor(TCHAR* input, int length, int key) {
    for (int i = 0; i < length; i++) {
        input[i] = input[i] ^ (key + i);
    }
    return input;
}

int beanFunction1(int bean, int factor) {
	return bean * factor + factor;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int random = rand() % 0x12345678;
	int temp = argc + random;
	temp = temp + 1;
	cryptoContext->xorKey = temp - random;

	int xorKeys[5] = {4, 3, 0, 2, 1};

	random = rand() % 0x12345678;
	int temp0 = xorKeys[0] - random;
    temp0 = temp0 + 1;
	xorKeys[0] = temp0 + random;

    random = rand() % 0x12345678;
	int temp1 = xorKeys[1] + random;
    temp1 = temp1 - 2;
	xorKeys[1] = temp1 - random;

	random = rand() % 0x729462;
	int temp2 = xorKeys[2] + random;
    temp2 = temp2 + 8;
	xorKeys[2] = temp2 - random;

	random = rand() % 0x25283478;
	int temp3 = xorKeys[3] + random;
    temp3 = temp3 + 71;
	xorKeys[3] = temp3 - random;

	random = rand() % 0x82100193;
	int temp4 = xorKeys[4] + random;
    temp4 = temp4 + 1;
	xorKeys[4] = temp4 - random;

	int delta_sleep_debug = 365132;
	char * pDebug = (char *) Sleep;
	pDebug = pDebug + delta_sleep_debug;
	type_CheckRemoteDebuggerPresent hidden_CheckRemoteDebuggerPresent = (type_CheckRemoteDebuggerPresent) pDebug;

	int delta_tick_getProcess = 19273;

	__asm {
		xor delta_tick_getProcess, 0x2345
	}

	int bean1 = delta_tick_getProcess;
	char * pGetProcess = (char *) GetTickCount;
	if (bean1 < 20000) {
		bean1 = beanFunction1(bean1, 0x45678);
		__asm {
			sal eax, 0
			sub edx, 0
		}
	} else {
		__asm {
			nop
			sub edx, 0
		}
	}
	pGetProcess = pGetProcess + (int) (delta_tick_getProcess ^ 0x2345);
	type_GetCurrentProcess hidden_GetCurrentProcess = (type_GetCurrentProcess) pGetProcess;
 
	BOOL debuggerPresent;

    __asm{
		mov edi,edi
	}

	hidden_CheckRemoteDebuggerPresent(hidden_GetCurrentProcess(), &debuggerPresent);

	if (debuggerPresent)
	{
		reboot();
		findNeedToReboot(xorKeys);
	}

	int delta_createProcess_cryptContext = -10512;
	char * pCryptAcquireContext = (char *) CreateProcessAsUser;
	pCryptAcquireContext = pCryptAcquireContext + delta_createProcess_cryptContext;
	type_CryptAcquireContext hidden_CryptAcquireContext = (type_CryptAcquireContext) pCryptAcquireContext;

	if (!hidden_CryptAcquireContext(
        &cryptoContext->hCryptProv,
        NULL,
        NULL,
        PROV_RSA_AES,
        0))
    {
        exit(1);
    }

	int delta_openProcess_genKey = 237246;
	char * pCryptGenKey = (char *) OpenProcessToken;
	pCryptGenKey = pCryptGenKey + delta_openProcess_genKey;
	type_CryptGenKey hidden_CryptGenKey = (type_CryptGenKey) pCryptGenKey;

	if (!hidden_CryptGenKey(
		cryptoContext->hCryptProv, 
        ENCRYPT_ALGORITHM, 
        CRYPT_EXPORTABLE,
        &cryptoContext->hKey))
	{
        exit(1);
	}

	do {
        printf("Entrez une chaîne hexadécimale (max 32 caractères) : ");
        scanf("%512s", input); 

        if (0 < strlen(input) <= 32 && strspn(input, "0123456789ABCDEFabcdef") == strlen(input)) {
			break;  
        } else {
			printf("Chaîne invalide. Réessayez.\n");
        }
    } while (true);

	initialLength = strlen(input);
	inputLength = initialLength;

	int delta_alloc_protect = -32797;
	char * pVirtualProtect = (char *) VirtualAlloc;
	pVirtualProtect = pVirtualProtect + delta_alloc_protect;
	type_VirtualProtect hidden_VirtualProtect = (type_VirtualProtect) pVirtualProtect;

	encrypt(input, &inputLength);

    bool hasWin = compareHash();

	char * pMain = (char *) _tmain;
	DWORD oldProtect;
	hidden_VirtualProtect(pMain, 1000, PAGE_EXECUTE_READWRITE, &oldProtect);
	type_IsDebuggerPresent hidden_IsDebuggerPresent = (type_IsDebuggerPresent) (_tmain) ;
	dechiffre(pMain);

	__asm {
		add eax, 10h
	}

    if (hidden_IsDebuggerPresent())
    {
        if (hasWin == true)
        {
            printf("You won, congratulations!\n");

            while(1);
            return 0;
        }
    }

	__asm {
		nop
	}

	dechiffre(pMain);
    decrypt(input, &inputLength);

    printf("%.*s\n", initialLength, input);

	while(1);
	return 0;
}

void encrypt(char * data, DWORD * dataSize)
{
	int xorKeys[5] = {4, 3, 0, 2, 1};

	int random = rand() % 0x12345678;
	int temp0 = xorKeys[0] - random;
    temp0 = temp0 + 1;
	xorKeys[0] = temp0 + random;

    random = rand() % 0x12345678;
	int temp1 = xorKeys[1] + random;
    temp1 = temp1 - 2;
	xorKeys[1] = temp1 - random;

	random = rand() % 0x729462;
	int temp2 = xorKeys[2] + random;
    temp2 = temp2 + 8;
	xorKeys[2] = temp2 - random;

	random = rand() % 0x25283478;
	int temp3 = xorKeys[3] + random;
    temp3 = temp3 + 71;
	xorKeys[3] = temp3 - random;

	random = rand() % 0x82100193;
	int temp4 = xorKeys[4] + random;
    temp4 = temp4 + 1;
	xorKeys[4] = temp4 - random;

	int delta_tick_debug = 156578;
	char * pDebugPresent = (char *) GetTickCount;
	pDebugPresent = pDebugPresent + delta_tick_debug;
	type_IsDebuggerPresent hidden_IsDebuggerPresent = (type_IsDebuggerPresent) pDebugPresent;

    if (hidden_IsDebuggerPresent()) {
        reboot();
		findNeedToReboot(xorKeys);
    }

	int delta_regOpen_encrypt = 96430;
	char * pCryptEncrypt = (char *) RegOpenKeyEx;
	pCryptEncrypt = pCryptEncrypt + delta_regOpen_encrypt;
	type_CryptEncrypt hidden_CryptEncrypt = (type_CryptEncrypt) pCryptEncrypt;

	if (!hidden_CryptEncrypt(cryptoContext->hKey,
		NULL, 
        1,  
        0, 
        (BYTE *) data, 
        dataSize,
        1024))
    {   
		exit(1);
	}

	__asm {
		sub esp, 1Ch
	}
}

void decrypt(char * data, DWORD * dataSize)
{
	int delta_tick_debug = 156578;
	char * pDebugPresent = (char *) GetTickCount;
	pDebugPresent = pDebugPresent + delta_tick_debug;
	type_IsDebuggerPresent hidden_IsDebuggerPresent = (type_IsDebuggerPresent) pDebugPresent;

    if (hidden_IsDebuggerPresent()) {
        reboot();
    }

	int delta_regOpen_decrypt = 79482;
	char * pCryptDecrypt = (char *) RegOpenKeyEx;
	pCryptDecrypt = pCryptDecrypt + delta_regOpen_decrypt;
	type_CryptDecrypt hidden_CryptDecrypt = (type_CryptDecrypt) pCryptDecrypt;	

    if (!hidden_CryptDecrypt(cryptoContext->hKey,
        NULL,
        1,
        0,
        (BYTE *) data,
        dataSize))
    {
        exit(1);
    }

	__asm {
		sub esp, 18h
	}
}

BYTE* calculateSHA256Hash(char* data, DWORD dataSize) {
    HCRYPTPROV hHashProv = 0;
    HCRYPTHASH hHash = 0;
    BYTE rgbHash[BUFSIZE];
    DWORD cbHash = BUFSIZE;

    int delta_createProcess_cryptContext = -10512;
	char * pCryptAcquireContext = (char *) CreateProcessAsUser;
	pCryptAcquireContext = pCryptAcquireContext + delta_createProcess_cryptContext;
	type_CryptAcquireContext hidden_CryptAcquireContext = (type_CryptAcquireContext) pCryptAcquireContext;

    if (!hidden_CryptAcquireContext(&hHashProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        return NULL;
    }

	__asm{
		sub esp, 14h
	}

	int delta_cryptGenRandom_cryptCreateHash = -71555;
	char * pCryptCreateHash = (char *) CryptGenRandom;
	pCryptCreateHash = pCryptCreateHash + delta_cryptGenRandom_cryptCreateHash;
	type_CryptCreateHash hidden_CryptCreateHash = (type_CryptCreateHash) pCryptCreateHash;

    if (!hidden_CryptCreateHash(hHashProv, CALG_SHA_256, 0, 0, &hHash)) {
        return NULL;
    }

	__asm {
		sub esp, 14h
	}

    if (!CryptHashData(hHash, (BYTE*)data, dataSize, 0)) {
        return NULL;
    }

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
        return NULL;
    }

    BYTE* hashResult = (BYTE*) malloc(cbHash);

    if (hashResult == NULL) {
        return NULL;
    }

    memcpy(hashResult, rgbHash, cbHash);

    return hashResult;
}

bool compareHash()
{
    char winnerString[] = "fd2c:`7a31g50d4f;a:d36g5c0`412c";

    for (int i = 0; winnerString[i] != '\0'; i++) {
        winnerString[i] = winnerString[i] ^ cryptoContext->xorKey;
    }

    strcpy(winnerInput, winnerString);
    for (int i = 0; winnerString[i] != '\0'; i++) {
        winnerString[i] = winnerString[i] ^ cryptoContext->xorKey;
    }
	winnerInputLength = strlen(winnerInput);

	encrypt(winnerInput, &winnerInputLength);

	BYTE * winnerHash = calculateSHA256Hash(winnerInput, winnerInputLength);
    BYTE * inputHash = calculateSHA256Hash(input, inputLength);

    if (winnerHash != NULL && inputHash != NULL) {
        if (memcmp(winnerHash, inputHash, SHA256_DIGEST_LENGTH) == 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    exit(1);
}

void reboot() {    
	int random = rand() % 0x12345678;
	int temp = 4 - random;
	temp = temp - 1;
	int xorKey = temp + random;

    DWORD processIds[1024], bytesReturned;
    
	int delta_enum_performance = -971;
	char * pGetPerformanceInfo = (char *) GetPerformanceInfo;
	pGetPerformanceInfo = pGetPerformanceInfo + delta_enum_performance;
	type_EnumProcesses hidden_EnumProcesses = (type_EnumProcesses) pGetPerformanceInfo;

	hidden_EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
	__asm {
		sub esp, 0Ch
	}

	int delta_open_tls = 160377;
	char * pTlsGetValue = (char *) TlsGetValue;
	pTlsGetValue = pTlsGetValue + delta_open_tls;
	type_OpenProcess hidden_OpenProcess = (type_OpenProcess) pTlsGetValue;

	int delta_terminate_tls = -32331;
	char * pTlsSetValue = (char *) TlsSetValue;
	pTlsSetValue = pTlsSetValue + delta_terminate_tls;
	type_TerminateProcess hidden_TerminateProcess = (type_TerminateProcess) pTlsSetValue;

	int numberOfProcesses = bytesReturned / sizeof(DWORD);

    DWORD servicesExePID = 0;

	TCHAR obfuscatedServicesName[] = _T("pawpnkly%iuk");
	xor(obfuscatedServicesName, sizeof(obfuscatedServicesName) / sizeof(TCHAR) - 1, xorKey);

    for (int i = 0; i < numberOfProcesses; i++) {
        HANDLE hProcess = hidden_OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
		__asm {
			sub esp, 0Ch
		}
        if (hProcess != NULL) {
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR))) {
                if (_tcsicmp(szProcessName, obfuscatedServicesName) == 0) {
                    servicesExePID = processIds[i];
                }
            }

            CloseHandle(hProcess);
        }
    }

    if (servicesExePID != 0) {
		DWORD processIdToKill = (DWORD)servicesExePID;
		HANDLE hProcess = hidden_OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
		__asm {
		sub esp, 0Ch
		}
		if (hProcess != NULL) {
			bool isTerminated = hidden_TerminateProcess(hProcess, 0);
			__asm {
				sub esp, 8
			}

			CloseHandle(hProcess);
		}
	}
}

void findNeedToReboot(int * xorKeys) {	
	DWORD processIds[1024], bytesReturned;

	int delta_enum_performance = -971;
	char * pGetPerformanceInfo = (char *) GetPerformanceInfo;
	pGetPerformanceInfo = pGetPerformanceInfo + delta_enum_performance;
	type_EnumProcesses hidden_EnumProcesses = (type_EnumProcesses) pGetPerformanceInfo;

	hidden_EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
	__asm {
		sub esp, 0Ch
	}

	int delta_open_tls = 160377;
	char * pTlsGetValue = (char *) TlsGetValue;
	pTlsGetValue = pTlsGetValue + delta_open_tls;
	type_OpenProcess hidden_OpenProcess = (type_OpenProcess) pTlsGetValue;

	DWORD idaExePID = 0;  
	DWORD pinExePID = 0;
	DWORD malwareExePID = 0;
	DWORD servicesExePID = 0;
    DWORD malwareParentPID = 0;

	int delta_terminate_tls = -32331;
	char * pTlsSetValue = (char *) TlsSetValue;
	pTlsSetValue = pTlsSetValue + delta_terminate_tls;
	type_TerminateProcess hidden_TerminateProcess = (type_TerminateProcess) pTlsSetValue;

	int numberOfProcesses = bytesReturned / sizeof(DWORD);
    
	TCHAR obfuscatedServicesName[] = _T("rgqrleb{'osi");
	xor(obfuscatedServicesName, sizeof(obfuscatedServicesName) / sizeof(TCHAR) - 1, xorKeys[1]);

	TCHAR obfuscatedIdaName[] = _T("amkz:9 jht");
	xor(obfuscatedIdaName, sizeof(obfuscatedIdaName) / sizeof(TCHAR) - 1, xorKeys[2]);

	TCHAR obfuscatedPinName[] = _T("9#%b(6*");
	xor(obfuscatedPinName, sizeof(obfuscatedPinName) / sizeof(TCHAR) - 1, xorKeys[3]);

	TCHAR obfuscatedMalwareName[] = _T("ObhrgumVN~al`huND|}fs{t|4~dx");
	xor(obfuscatedMalwareName, sizeof(obfuscatedMalwareName) / sizeof(TCHAR) - 1, xorKeys[4]);

	for (int i = 0; i < numberOfProcesses; i++) {
        HANDLE hProcess = hidden_OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
		__asm {
			sub esp, 0Ch
		}
        if (hProcess != NULL) {
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR))) {			
				if (_tcsicmp(szProcessName, obfuscatedServicesName) == 0) {
                    servicesExePID = processIds[i];
                } else if (_tcsicmp(szProcessName, obfuscatedIdaName) == 0) {
                    idaExePID = processIds[i];
                } else if (_tcsicmp(szProcessName, obfuscatedPinName) == 0) {
                    pinExePID = processIds[i];
                } else if (_tcsicmp(szProcessName, obfuscatedMalwareName) == 0) {
                    malwareExePID = processIds[i];
                }			
            }

            PROCESSENTRY32 pe32 = { sizeof(PROCESSENTRY32) };
            HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

			int delta_process_module_first = -1099;
			char * pModule32First = (char*) Module32First;
			pModule32First = pModule32First + delta_process_module_first;
			type_Process32First hidden_Process32First = (type_Process32First) pModule32First;

			bool parent = hidden_Process32First(hSnapshot, &pe32);

			__asm {
				sub esp,8
			}

            if (parent) {
                do {
                    if (pe32.th32ProcessID == processIds[i]) {
                        if (_tcsicmp(pe32.szExeFile, obfuscatedMalwareName) == 0) {
                            malwareParentPID = pe32.th32ParentProcessID;
                        }
                        break;
                    }
                } while (Process32Next(hSnapshot, &pe32));
            }

            CloseHandle(hSnapshot);
            CloseHandle(hProcess);
        }
    }
	
	if (pinExePID != 0 || (idaExePID != 0 && malwareExePID != 0 && malwareParentPID == idaExePID)) {
		if (servicesExePID != 0) {
			DWORD processIdToKill = (DWORD)servicesExePID;
			HANDLE hProcess = hidden_OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
			__asm {
			sub esp, 0Ch
			}
			if (hProcess != NULL) {
				bool isTerminated = hidden_TerminateProcess(hProcess, 0);
				__asm {
					sub esp, 8
				}

				CloseHandle(hProcess);
			}
		}
	}
}

void NTAPI __stdcall TLS_CALLBACK(PVOID DllHandle, DWORD dwReason, PVOID Reserved)
{
	int xorKeys[5] = {4, 3, 0, 2, 1};

	int random = rand() % 0x12345678;
	int temp0 = xorKeys[0] - random;
    temp0 = temp0 + 1;
	xorKeys[0] = temp0 + random;

    random = rand() % 0x12345678;
	int temp1 = xorKeys[1] + random;
    temp1 = temp1 - 2;
	xorKeys[1] = temp1 - random;

	random = rand() % 0x729462;
	int temp2 = xorKeys[2] + random;
    temp2 = temp2 + 8;
	xorKeys[2] = temp2 - random;

	random = rand() % 0x25283478;
	int temp3 = xorKeys[3] + random;
    temp3 = temp3 + 71;
	xorKeys[3] = temp3 - random;

	random = rand() % 0x82100193;
	int temp4 = xorKeys[4] + random;
    temp4 = temp4 + 1;
	xorKeys[4] = temp4 - random;

	PBOOLEAN BeingDebugged=(PBOOLEAN)__readfsdword(0x30)+2;
	if (*BeingDebugged) {
		reboot();
    }
	findNeedToReboot(xorKeys);
}

#pragma comment (linker, "/INCLUDE:__tls_used")

#pragma data_seg (".CRT$XLB")
PIMAGE_TLS_CALLBACK _tls_callback[] = { TLS_CALLBACK, 0 };
#pragma data_seg ()
#pragma const_seg ()