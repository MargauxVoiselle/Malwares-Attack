J'ai deux bouts de code assembleur :

004012C9 8B 0D 80 33 40 00    mov         ecx,dword ptr [cryptoContext (403380h)]  
004012CF 8B 51 04             mov         edx,dword ptr [ecx+4]  
004012D2 83 C4 10             add         esp,10h  
004012D5 68 00 04 00 00       push        400h  
004012DA 57                   push        edi  
004012DB 53                   push        ebx  
004012DC 6A 00                push        0  
004012DE 6A 01                push        1  
004012E0 6A 00                push        0  
004012E2 52                   push        edx  
004012E3 FF 15 00 20 40 00    call        dword ptr [__imp__CryptEncrypt@28 (402000h)]  
004012E9 85 C0                test        eax,eax  
004012EB 75 12                jne         $LN5 (4012FFh)  

et

004012C9 8B 0D 80 33 40 00    mov         ecx,dword ptr [cryptoContext (403380h)]  
004012CF 8B 51 04             mov         edx,dword ptr [ecx+4]  
004012D2 A1 00 20 40 00       mov         eax,dword ptr [__imp__RegOpenKeyExW@20 (402000h)]  
004012D7 68 00 04 00 00       push        400h  
004012DC 57                   push        edi  
004012DD 53                   push        ebx  
004012DE 6A 00                push        0  
004012E0 6A 01                push        1  
004012E2 6A 00                push        0  
004012E4 52                   push        edx  
004012E5 05 B1 78 01 00       add         eax,178B1h  
004012EA FF D0                call        eax  
004012EC 83 C4 2C             add         esp,2Ch  
004012EF 85 C0                test        eax,eax  
004012F1 75 12                jne         $LN5 (401305h) 

Ces deux codes sont censés faire la même chose, le second cache juste l'appel de la fonction CryptEncrypt et pourtant,  quand la fonction qui contient le code associé à ce code assembleur se termine, on ne revient pas dans le main à l'instruction suivant l'appel de fonction. Pourquoi ?