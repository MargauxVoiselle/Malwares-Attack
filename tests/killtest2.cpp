#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <iostream>

#pragma comment(lib, "Psapi.lib")

int main() {
    // Obtenez la liste des PIDs
    DWORD processIds[1024], bytesReturned;
    EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
    int numberOfProcesses = bytesReturned / sizeof(DWORD);

    DWORD firstPidWithNoName = 0;  // Variable pour stocker le premier PID sans nom

    for (int i = 0; i < numberOfProcesses; i++) {
        // Ouvrez un handle vers le processus
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
        if (hProcess != NULL) {
            TCHAR szProcessName[MAX_PATH];

            // Obtenez le nom du module de base pour ce processus
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR)) == 0) {
                // Stockez le PID si le nom n'est pas trouvé
                firstPidWithNoName = processIds[i];
                _tprintf(_T("Le PID %u n'a pas de nom significatif.\n"), firstPidWithNoName);
                break;  // Sortez de la boucle, car nous avons trouvé le premier PID sans nom
            }

            CloseHandle(hProcess);
        }
    }

    if (firstPidWithNoName == 0) {
        _tprintf(_T("Aucun PID n'a été trouvé sans nom significatif.\n"));
    }
	else {
		DWORD processIdToKill = (DWORD)firstPidWithNoName;
		HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
		if (hProcess != NULL) {
			if (TerminateProcess(hProcess, 0)) {
				_tprintf(_T("Le processus avec le PID %u a été terminé avec succès.\n"), processIdToKill);
			} else {
				_tprintf(_T("Erreur lors de la terminaison du processus. Code d'erreur : %u\n"), GetLastError());
			}
			CloseHandle(hProcess);
		} else {
			_tprintf(_T("Impossible d'ouvrir le handle du processus. Code d'erreur : %u\n"), GetLastError());
		}
	}
	while(1);
    return 0;
}