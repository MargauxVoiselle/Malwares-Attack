
#include "stdafx.h"
#include <iostream>
#include <iomanip>
#include <cstdint>  // Pour uint32_t et uint64_t
#include <cstring>  // Pour strlen

using namespace std;

// Définition des fonctions auxiliaires
#define SHA1_ROL(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
#define SHA1_BLK(i) (m_block[(i) & 15] = SHA1_ROL(m_block[(i + 13) & 15] ^ m_block[(i + 8) & 15] ^ m_block[(i + 2) & 15] ^ m_block[i & 15], 1))

// Fonction principale du hachage SHA-1
void sha1(const char* input, uint32_t length, uint32_t hash[5]) {
    // Initialisation des variables de hachage
    hash[0] = 0x67452301;
    hash[1] = 0xEFCDAB89;
    hash[2] = 0x98BADCFE;
    hash[3] = 0x10325476;
    hash[4] = 0xC3D2E1F0;

    // Calcul de la taille du message en bits
    uint64_t bitLength = length * 8;

    // Ajout du bit '1' au message
    uint32_t paddingLength = (length % 64 < 56) ? (56 - length % 64) : (120 - length % 64);
    char padding[64] = {0x80};
    memcpy(padding, input, length);
    memcpy(padding + length, padding, paddingLength);
    memcpy(padding + 56, &bitLength, 8);

    // Traitement par blocs de 512 bits
    for (uint32_t i = 0; i < length + paddingLength + 8; i += 64) {
        // Prépare le bloc de message
        uint32_t w[80];
        uint32_t* m_block = reinterpret_cast<uint32_t*>(padding + i);
        for (uint32_t j = 0; j < 16; ++j)
            w[j] = m_block[j];

        // Étend le bloc de message
        for (uint32_t j = 16; j < 80; ++j)
            w[j] = SHA1_ROL(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);

        // Initialise les variables de travail
        uint32_t a = hash[0];
        uint32_t b = hash[1];
        uint32_t c = hash[2];
        uint32_t d = hash[3];
        uint32_t e = hash[4];

        // Applique les opérations de hachage
        for (uint32_t j = 0; j < 80; ++j) {
            uint32_t f, k;
            if (j < 20) {
                f = (b & c) | ((~b) & d);
                k = 0x5A827999;
            } else if (j < 40) {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            } else if (j < 60) {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            } else {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }

            uint32_t temp = SHA1_ROL(a, 5) + f + e + k + w[j];
            e = d;
            d = c;
            c = SHA1_ROL(b, 30);
            b = a;
            a = temp;
        }

        // Met à jour les variables de hachage
        hash[0] += a;
        hash[1] += b;
        hash[2] += c;
        hash[3] += d;
        hash[4] += e;
    }
}

int _tmain(int argc, _TCHAR* argv[])
{
	const char* message = "Hello, this is a SHA-1 example.";

    uint32_t hash[5];
    sha1(message, std::strlen(message), hash); // Utilisation de std::strlen

    std::cout << "SHA-1 Hash: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << std::hex << std::setw(8) << std::setfill('0') << hash[i];
    }
    std::cout << std::endl;
	while(1);
    return 0;
}

