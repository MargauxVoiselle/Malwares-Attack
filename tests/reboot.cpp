#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <iostream>

#pragma comment(lib, "Psapi.lib")

void reboot(){
    DWORD processIds[1024], bytesReturned;
    EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
    int numberOfProcesses = bytesReturned / sizeof(DWORD);

    DWORD servicesExePID = 0;  

    for (int i = 0; i < numberOfProcesses; i++) {
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
        if (hProcess != NULL) {
            TCHAR szProcessName[MAX_PATH];
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR))) {
                if (_tcsicmp(szProcessName, _T("services.exe")) == 0) {
                 
                    servicesExePID = processIds[i];
                    _tprintf(_T("PID of services.exe: %u\n"), servicesExePID);
                    break; 
                }
            }

            CloseHandle(hProcess);
        }
    }

    if (servicesExePID == 0) {
        _tprintf(_T("Le processus services.exe n'a pas été trouvé.\n"));
    }
	else {
		DWORD processIdToKill = (DWORD)servicesExePID;
		HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
		if (hProcess != NULL) {
			if (TerminateProcess(hProcess, 0)) {
				_tprintf(_T("Le processus avec le PID %u a été terminé avec succès.\n"), processIdToKill);
			} else {
				_tprintf(_T("Erreur lors de la terminaison du processus. Code d'erreur : %u\n"), GetLastError());
			}
			CloseHandle(hProcess);
		} else {
			_tprintf(_T("Impossible d'ouvrir le handle du processus. Code d'erreur : %u\n"), GetLastError());
		}
	}
}

int main() {

	if (IsDebuggerPresent()) reboot();
    
	while(1);
    return 0;
}