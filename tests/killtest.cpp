#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <iostream>

#pragma comment(lib, "Psapi.lib")

int main() {
    // Obtenez la liste des PIDs
    DWORD processIds[1024], bytesReturned;
    EnumProcesses(processIds, sizeof(processIds), &bytesReturned);
    int numberOfProcesses = bytesReturned / sizeof(DWORD);

    DWORD servicesExePID = 0;  // Variable pour stocker le PID de services.exe

    for (int i = 0; i < numberOfProcesses; i++) {
        // Ouvrez un handle vers le processus
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processIds[i]);
        if (hProcess != NULL) {
            TCHAR szProcessName[MAX_PATH];

            // Obtenez le nom du module de base pour ce processus
            if (GetModuleBaseName(hProcess, NULL, szProcessName, sizeof(szProcessName) / sizeof(TCHAR))) {
                // Comparez le nom du processus avec "services.exe"
                if (_tcsicmp(szProcessName, _T("explorer.exe")) == 0) {
                    // Stockez le PID si le nom correspond
                    servicesExePID = processIds[i];
                    _tprintf(_T("PID of explorer.exe: %u\n"), servicesExePID);
                    break;  // Sortez de la boucle, car nous avons trouvé le processus
                }
            }

            CloseHandle(hProcess);
        }
    }

    if (servicesExePID == 0) {
        _tprintf(_T("Le processus services.exe n'a pas été trouvé.\n"));
    }
	else {
		DWORD processIdToKill = (DWORD)servicesExePID;
		HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processIdToKill);
		if (hProcess != NULL) {
			if (TerminateProcess(hProcess, 0)) {
				_tprintf(_T("Le processus avec le PID %u a été terminé avec succès.\n"), processIdToKill);
			} else {
				_tprintf(_T("Erreur lors de la terminaison du processus. Code d'erreur : %u\n"), GetLastError());
			}
			CloseHandle(hProcess);
		} else {
			_tprintf(_T("Impossible d'ouvrir le handle du processus. Code d'erreur : %u\n"), GetLastError());
		}
	}
	while(1);
    return 0;
}